\chapter{Popis kontraktů softwarových rozhraní}

	\section{Koncept kontraktů softwarových modulů}
		Abychom v softwarovém inženýrství zajistili znovupoužitelnost a bezchybnost nezávislých komponent, je třeba specifikovat, jakým způsobem se mají používat a jak s nimi komunikovat. Jedná se o kontrakt mezi tím, kdo komponentu implementoval (dodavatel, vývojář) a tím, kdo ji používá (klient, uživatel). Vývojář zaručuje, že modul bude fungovat dle specifikace, za předpokladu, že bude používán správně. Správná komunikace mezi moduly bývá zpravidla zajištěna použitím rozhraní, která vynucují určité chování. Nicméně rozhraní uživatele omezuje pouze v použití správných metod a datových typů, ale na rozdíl od kontraktů již neklade požadavky na samotné hodnoty. Kontrakty mohou působit dojmem, že slouží jako náhrada testů, nicméně se nejedná o zaměnitelné funkce a naopak by se měly navzájem doplňovat. 
		
	\section{Vliv na kvalitu kódu a software}
		Použití kontraktů v kódu přináší mnoho výhod, které mohou zvýšit kvalitu vývoje, respektive pak výsledného softwaru. Často vynucují správné chování při statické nebo dynamické kontrole a zajišťují tak správnost toku dat. Poskytují dodatečné informace při popisu rozhraní a pomáhají tak v lepší orientaci v projektu. Při použití kontraktů tak vývojář ví, jaké nároky může mít na danou operaci, a co se na oplátku očekává, že dodrží. Použití kontraktů může také pomoci při debuggingu, či při analýze vstupů a výstupů. 
		
		Z využití kontraktů však mohou také plynout určité nevýhody. Jednou z nich je chybné použití kontraktů důsledkem špatné analýzy, které může vést k různým problémům. Kontrakt  může být příliš omezující a bránit tak plnému využití funkce, či naopak může být příliš volný a dovolovat nevalidní hodnoty. V závislosti na typu daného kontraktu může také dojít ke zvýšení režie a tedy zpomalení vykonávaného kódu, což by mohl být problém zejména u časově kritických operací. Obecně ale platí, že při zodpovědném používání, mohou být kontrakty velice prospěšné a přispět ke zlepšení kvality vyvíjeného software.
	%I přesto, že nejsou k dispozici statistické údaje o pozitivním dopadu kontraktů, projekty, které kontrakty používají, je při vydávání nových verzí zachovávají a naopak stále rozvíjejí. To lze považovat za známku toho, že se jedná o užitečný prvek.
	
	\section{Design by contract}
		Pojem design by contract zavedl francouzský profesor Bertrand Meyer. První větší zmínka je uveden v publikaci \emph{Design by Contract, Technical Report} v roce 1987. Profesor v průběhu let působil na řadě univerzit jako např. v Politecnico di Milano či ETH Zurich a je autorem mnoha publikací a knih. Mimo design by contract, byl jeho významným příspěvkem do oblasti softwarového inženýrství programovací jazyk Eiffel, který je s DbC úzce spjat \cite{meyerBio}\cite{DesignByContractComponentware}\cite{eiffel}.	
	
		Hlavním cílem design by contract je zvýšení spolehlivosti a správnosti u rozsáhlých softwarových projektů. Principem DbC je zajištění formální dohody mezi vývojářem a uživatelem určitého softwarového modulu. Pomocí design by contract může vývojář specifikovat očekávané hodnoty. Za předpokladu, že vývojář odvede kvalitní práci a uživatel tento kontrakt dodrží, mělo by to zamezit množství chyb spojených s integrací. Desing by contract zajišťuje správnost pomocí \emph{assertions}, kterých jsou celkem tři typy. Prvním z nich jsou tzv. pre-condtions, které zajišťují správné hodnoty vstupních parametrů, tedy hodnoty před tím, než je provedena určitá operace. Jejich opakem jsou pak post-conditions, které naopak zajišťují správnost výstupu, tedy hodnot po provedení dané operace. Třetím typem jsou tzv class invariants, nebo-li neměnné proměnné, které musejí platit po celou dobu. Je možné říci, že class invariant je pre-condition a post-condition pro všechny veřejné metody v dané třídě.
	
	Podmínky jsou definovány pomocí konstrukcí v kódu programu. V závislosti na typu daného kontraktu, mohou poskytovat statickou kontrolu a/nebo jsou ověřovány při běhu. V případě, že byla některá z nich porušena, je vyvolána výjimka. Tímto chováním je zajištěno, že kontrakt bude dodržen \cite{contractsInWild}\cite{DesignByContractComponentware}.
	
	\section{Rozdělení kontraktů}
		Kontrakty můžeme rozdělit do několika kategorií dle způsobu jejich použití:
			
		\begin{itemize}
			\item Podmíněné výjimky za běhu (Conditional Runtime Exceptions - CRE)
			\item API
			\item Assert
			\item Anotace
			\item Ostatní
		\end{itemize}				
		
		\paragraph{CRE}
		 Nejběžnějším způsobem pro specifikaci kontraktů jsou podmíněné výjimky, které jsou vyvolány za běhu při porušení kontraktu (podmínky). K dispozici jsou různé typy výjimek, které je možné použít, mezi ně patří např. IllegalStateException, IllegalArgumentException, NullpointerException, IndexOutOfBoundsException či UnsupportedOperationException. Všechny tyto výjimky jsou součástí standardní Javy, což je jeden z faktorů, proč je tento způsob tak četný.
		
		\paragraph{API}
		Další možností implementace kontraktů je využití specializovaného API, které poskytuje metody pro práci s kontrakty. Typicky se jedná o rozšířenou práci s výjimkami, se kterou se navenek pracuje jako se statickými metodami. Tato API zpravidla poskytují širší možnosti a umožňují tak sofistikovanější práci s kontrakty.
		
		\paragraph{Assert}
		Použitím klíčového slova \texttt{assert} je také možné kontrakty vytvářet. Stejně jako v případě výjimek, i zde se jedná o standardní součást jazyka. Aserce je tvrzení o stavu programu, které vyvolá výjimku není-li dodrženo. Assert je typicky spojováno s tvorbou testů, ale je možné jej použít i pro definici kontraktů.
		
		\paragraph{Anotace}
		Dalším způsobem je využití anotací, pomocí kterých je také možné specifikovat kontrakty. Anotace je možné uvádět před specifikaci tříd či metod nebo například i před parametry, v závislosti na dané anotaci. Některé anotace pro specifikaci kontraktů poskytuje také standardní knihovny Java, nicméně pro pokročilejší funkce je třeba využít externí zdroje.
		
		\paragraph{Ostatní}
		Existují také různé specifické způsoby definice kontraktů, které nepatří do žádné z těchto čtyř kategorií, nicméně nejsou příliš časté. Příkladem této kategorie může být jContractor.
	
	
	\section{Způsoby popisu kontraktů v Java technologiích}
		V Java exstuje celá řada nástrojů, které umožňují práci s kontrakty. Liší se v nabízených možnostech a ve způsobech, jak se s nimi pracuje. Některé z nich se již dále nevyvíjejí nicméně jsou jsou stále používány. Zde je výčet některých z těchto nástrojů:		
	
		\subsection{Guava Preconditions}
			Knihovna Guava od Google poskytuje řadu nových funkcí jako například různé kolekce, primitiva, práce se souběžnými programy atd. Z hlediska kontraktů je pro nás však zajímává pouze třída \texttt{Preconditions}, která poskytuje metody pro validaci různých stavů. Je zde řada metod, které typicky začínají klíčovým slovem \texttt{check*} (např. \texttt{checkArgument}, \texttt{checkState}, \texttt{checkNotNull} atd.). Tyto metody jsou použity běžně v kódu programu a poskytují kontrolu pro vstupní argumenty, jedná se tedy pouze o pre-conditions, jak již název napovídá. Při porušení takovéto podmínky je pak vyvolána podmínky při běhu programu. Volitelnou částí každé metody je také zpráva, která má být při porušení kontraktu zobrazena. Tuto zprávu je pak možné parametrizovat dalšími argumenty. Guava Preconditions poskytuje dobré prostředí pro práci s kontrakty, avšak její nevýhodou je, že je omezena pouze na pre-conditions. Zde je vidět příklad použití Preconditons v kódu:\\\\
			\- \- \- \- \- \texttt{public void guavaPreconditionsExample(Object x)\{}\\
			\- \- \- \- \- \- \- \- \- \- \texttt{String message = "x cannot be null.";}\\ 
        	\- \- \- \- \- \- \- \- \- \- \texttt{Preconditions.checkNotNull(x, message);}\\
    		\- \- \- \- \- \texttt{\}}\\
    		
    		V tomto příkladu je vstupní parametr \texttt{Object x} omezen a vstupem nemůže být hodnota \texttt{null}, pokud se tak stane, nastane standardní výjimka \texttt{java.lang.NullPointerException}. Typ výjimky, který knihovna vrací je závislý na dané metodě (např. pro metodu \texttt{checkArgument(boolean)} je vrácena výjimka \texttt{IllegalArgumentException}).
		
		\subsection{JSR305}
			JSR305 umožňuje specifikaci kontraktů pomocí anotací. Na rozdíl od Guava Preconditions umožňuje také použití post-conditions i class invariants. Obecně platí, že anotace, které jsou uvedeny před argumenty metod např: \texttt{@Nonnull Object x} specifikují pre-conditions pro parametr dané metody. Pokud je anotace uvedena pro celou metodu, jedná se o post-condition a kontrakt se tak váže na výstupní hodnotu metody. V případě, že je anotace vázaná na třídu, jedná se o class invariant. Některé anotace je možné použít jako libovolný druh, nicméně mnoho z nich je specializována pro jeden či dva typy podmínek. 
			
			Pokud je kontrakt porušen, je opět vyhozena výjimka, v tomto případě \texttt{IllegalArgumentException}. Na rozdíl od Guava, zde není nativní možnost pro zadání vlastní chybové zprávy v případě porušení kontraktu, ale výchozí chyba je poměrně samovysvětlující. JSR305 nicméně neposkytuje pouze striktní podmínky, které při porušení skončí chybou, ale umožňuje také anotace, které slouží jako informace pro vývojáře. Např. anotace \texttt{@CheckForNull} upozorňuje, že daný objekt může nabýt hodnoty \texttt{null}, ale nevynucuje žádné chování a je pouze na vývojáři, jak s touto informací naloží. Příklad zobrazující všechny tři typy kontraktů je vidět zde:\\\\			
			\- \- \- \- \- \texttt{@ParametersAreNullableByDefault}\\
			\- \- \- \- \- \texttt{public class JSR3053ExampleClass \{}\\\\
   			\- \- \- \- \- \- \- \- \- \- \texttt{@CheckReturnValue}\\
    		\- \- \- \- \- \- \- \- \- \- \texttt{public Obejct JSR305Example(@Nonnull Object x)\{}\\
      		\- \- \- \- \- \- \- \- \- \- \- \- \- \- \- \texttt{// other code}\\
    		\- \- \- \- \- \- \- \- \- \- \texttt{\}}\\
			\- \- \- \- \- \texttt{\}}\\
			
			JSR značí Java Specification Requests, tedy specifikační požadavky pro Java. Jedná se o popisy finálních specifikací pro jazyk Java. Jednotlivé JSR se postupně schvalují a zhodnocují a jejich průběžný stav je možné sledovat. JSR305 rozšiřuje standardní knihovnu \texttt{javax.annotations}. I přesto, že JSR305 je ve stavu \emph{dormant}\footnote{\emph{Dormant} značí, že práce na tomto JSR projektu byla pozastavena. Může to být na základě hlasování komise, či protože dané JSR dosáhlo konec své životnosti.}, stále je hojně využíváno v řadě projektech a má tak smysl jej zkoumat.
			\cite{jsr305} 
	
	
		\subsection{Cofoja}
			Contracts for Java, či zkráceně Cofoja, je aplikační rámec, který mimo jiné umožňuje práci s kontrakty. Kontrakty jsou definovány na úrovni anotace a slouží pouze ke kontrole za běhu programu, neposkytují tedy statickou kontrolu. Cofoja umožňuje použití všech tří typů podmínek a zajišťuje to pomocí klíčových slov \texttt{@Requires} pro pre-conditions, 
\texttt{@Ensures} pro post-conditions a \texttt{@Invariant} pro class invariants \cite{cofoja}. Praktické využití v kódu pak může vypadat takto:\\\\
				\- \- \- \- \- \texttt{@Requires("x >= 0")}\\
				\- \- \- \- \- \texttt{@Ensures("result >= 0")}\\
				\- \- \- \- \- \texttt{static double sqrt(double x);}\\


		\subsection{valid4j}
			Valid4j je jednoduchý nástroj, který poskytuje metody pro práci s kontrakty za pomoci aserce. Podobně jako jiné nástroje využívá klíčových slov \texttt{require} pro pre-conditions a \texttt{ensure} pro post-conditions. Tento nástroj neposkytuje podporu pro class invariants za pomocí specializovaných metod ale tohoto chování je možné dosáhnout použitím zmíněných metod \cite{valid4j}. Zde je část kódu implementující kontrakty nástrojem valid4j.\\\\  
				\- \- \- \- \- \texttt{public Stuff method(Object param) \{}\\
				\- \- \- \- \- \- \- \- \- \- \texttt{require(param, notNullValue());}\\
				\- \- \- \- \- \- \- \- \- \- \texttt{require(getState(), equalTo(GOOD));}\\
				\- \- \- \- \- \- \- \- \- \- \texttt{...}\\
				\- \- \- \- \- \- \- \- \- \- \texttt{ensure(getState(), equalTo(GREAT));}\\
				\- \- \- \- \- \- \- \- \- \- \texttt{return ensure(r, notNullValue());}\\
				\- \- \- \- \- \texttt{\}}\\	
	
	\section{Kontrakty v jiných technologiích}
		Použití kontraktů samozřejmě není omezeno pouze na Java, ale je rozšířeno do mnoha jiných jazyků. Mimo použití běžně dostupných prostředků, jako jsou například výjimky či aserce, které jsou k dispozici téměř v každém jazyce, existují také specializované nástroje, které umožňují rozšířenou práci s kontrakty.
		
		\subsection{Code Contracts v .NET}
			Prvním příkladem může být projekt Code Contracts, který byl vyvinut společností Microsoft a umožňuje použití kontraktů v .NET jazycích. Jedná se o open-source knihovnu, která formou API poskytuje funkce pro specifikaci kontraktů. Funguje na jednoduchém princip volání funkcí podobně jako Guava Preconditions, nicméně umožňuje použití všech tří typů kontraktů (pre-conditions, post-conditions a class invariants). Základními funkcemi jsou \texttt{Contract.Requires()} pro vynucení správného vstupu, tedy pre-conditions, \texttt{Contract.Ensures()} pro zajištění správného výstupu, tedy post-condition a \texttt{Contract.Invariant()} pro reprezentaci class invariant. Mimo těchto základních funkcí poskytuje také různé specifické operace, se kterými je možné vytvářet komplexnější kontrakty. Umožňuje také např. specifikaci vyhozené výjimky \cite{codeContracts}\cite{codeContracts2}. V následujícím příkladu je vidět použití základních konstrukcí:\\\\
			\- \- \- \- \- \texttt{Contract.Requires( x != null );}\\
			\- \- \- \- \- \texttt{Contract.Ensures( this.F > 0 );}\\
			\- \- \- \- \- \texttt{Contract.Invariant(this.y >= 0);}\\  
			